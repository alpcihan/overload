//--------------------------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------------------------
#include "Assets/Overload/Shaders/Utils/Math.hlsl"
#include "Assets/Overload/Shaders/Utils/MeshOcean.hlsl"

//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------
#pragma kernel CSMain

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
cbuffer CB {
    MESH_OCEAN_DATA
    // float _seed;
};

//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
RWStructuredBuffer<uint> _indirectArgs;
RWStructuredBuffer<InstanceData> _modelMatrices;

//--------------------------------------------------------------------------------------
// Mesh Ocean Update Per Instance Data Compute Shader
//--------------------------------------------------------------------------------------
[numthreads(32,32,1)]
void CSMain (uint2 id : SV_DispatchThreadID) {
    if(id.x > _oceanDimension || id.y > _oceanDimension) return;

    // calculate ocean mesh index
    uint2 idx = calculateOceanMeshIndex(id, _oceanDimension, _oceanUnitSize, _oceanFluxOffset); 

    // calculate transform
    const float2 worldPos2D = calculateOceanMeshPos2DWorld(idx, _oceanDimension, _oceanUnitSize, _oceanFluxOffset, _oceanCenter);

    // update per instance data
    _modelMatrices[id].model[0][0] = _oceanUnitSize;                        // scale x
    _modelMatrices[id].model[1][1] = 1;                                     // scale y
    _modelMatrices[id].model[2][2] = _oceanUnitSize;                        // scale z
    _modelMatrices[id].model[0][3] = worldPos2D.x;                          // position x
    _modelMatrices[id].model[1][3] = _oceanCenter.y;                        // position y
    _modelMatrices[id].model[2][3] = worldPos2D.y;                          // position z

    _modelMatrices[id].modelInverse = inverse(_modelMatrices[id].model);    // inverse
}