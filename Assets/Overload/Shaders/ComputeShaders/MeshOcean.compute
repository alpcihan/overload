//--------------------------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------------------------
#include "Assets/Overload/Shaders/Utils/Math.hlsl"
#include "Assets/Overload/Shaders/Utils/MeshOcean.hlsl"

//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------
#pragma kernel CSMain

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
cbuffer CB {
    MESH_OCEAN_DATA
    float _seed;
};

//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
RWStructuredBuffer<uint> _indirectArgs;
RWStructuredBuffer<InstanceData> _modelMatrices;

//--------------------------------------------------------------------------------------
// Mesh Ocean Compute Shader
//--------------------------------------------------------------------------------------
inline float calculateHeightOffset(uint2 idx) {
    float h = noise(float3(
                        (_oceanWaveFrequency*idx)/_oceanDimension,
                        _seed
                    ));
    h *= _oceanMaxHeight;

    return h;
}

inline float3 calculateWorldPos(uint2 idx, float scaleY) {
    float startIdx = -_oceanDimension * 0.5;

    float x = (startIdx + idx.x) * _oceanUnitSize + _oceanCenter.x;
    float z = (startIdx + idx.y) * _oceanUnitSize + _oceanCenter.z;
    float y = scaleY * 0.5 + _oceanCenter.y;

    return float3(x, y, z);
}

[numthreads(1024,1,1)]
void CSMain (uint id : SV_DispatchThreadID) {
    if(id > _indirectArgs[1]) return;

    // get ocean unit index
    uint2 idx = uint2(_modelMatrices[id].model[0][0], _modelMatrices[id].model[1][1]);
    
    // calculate transform
    const float scaleY = calculateHeightOffset(idx);
    const float3 worldPos = calculateWorldPos(idx, scaleY);

    // update instance data
    _modelMatrices[id].model[0][0] = _oceanUnitSize;
    _modelMatrices[id].model[1][1] = scaleY;
    _modelMatrices[id].model[2][2] = _oceanUnitSize;
    _modelMatrices[id].model[0][3] = worldPos.x;
    _modelMatrices[id].model[1][3] = worldPos.y;
    _modelMatrices[id].model[2][3] = worldPos.z;
    _modelMatrices[id].modelInverse = inverse(_modelMatrices[id].model);
}