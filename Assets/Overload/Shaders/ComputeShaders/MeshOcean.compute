//--------------------------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------------------------
#include "Assets/Overload/Shaders/Utils/Math.hlsl"
#include "Assets/Overload/Shaders/Utils/MeshOcean.hlsl"

//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------
#pragma kernel CSMain

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
cbuffer CB {
    MESH_OCEAN_DATA
    float _seed;
};

//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
RWStructuredBuffer<uint> _indirectArgs;
RWStructuredBuffer<InstanceData> _modelMatrices;

//--------------------------------------------------------------------------------------
// Mesh Ocean Compute Shader
//--------------------------------------------------------------------------------------
inline float calculateHeightOffset(float2 unitOffsetLocal) {
    float h = noise(float3(
                        unitOffsetLocal,
                        _seed
                    ));
    h *= _oceanMaxHeight;

    return h;
}

inline float2 calculateUnitLocalPos(uint2 idx) {
    const float oceanSize = _oceanDimension * _oceanUnitSize;
    const float halfOceanSize = oceanSize * 0.5;
    const float halfUnitSize = _oceanUnitSize * 0.5;

    // ocean bound                      [0, OceanSize - 1]
    float2 xz = idx * _oceanUnitSize;

    // add flux offset                  [0 + fluxOffset, OceanSize - 1 + fluxOffset]
    xz += _oceanFluxOffset.xy;

    // mod by ocean size                [0, OceanSize - 1]
    xz %= float2(oceanSize, oceanSize);

    // calculate center of the mesh     [0 + halfUnitSize, OceanSize - 1 + halfUnitSize] 
    xz += float2(halfUnitSize, halfUnitSize);

    // center the ocean at local space
    xz -= float2(halfOceanSize, halfOceanSize);

    // calculate the world space position
    xz += _oceanCenter.xy;
    
    return xz;
}

[numthreads(1024,1,1)]
void CSMain (uint id : SV_DispatchThreadID) {
    if(id > _indirectArgs[1]) return;

    // get ocean unit index
    uint2 idx = uint2(_modelMatrices[id].model[0][0], _modelMatrices[id].model[1][1]);
    idx += (uint)(_oceanFluxOffset / _oceanUnitSize);
    idx %= _oceanDimension;

    // calculate transform
    const float2 worldPos = calculateUnitLocalPos(idx);

    const float2 unitOffsetLocal = (_oceanWaveFrequency * _oceanUnitSize * idx) / _oceanDimension;
    const float scaleY = calculateHeightOffset(unitOffsetLocal);
    const float h = scaleY * 0.5 + _oceanCenter.y;

    // update instance data
    _modelMatrices[id].model[0][0] = _oceanUnitSize;                        // scale x
    _modelMatrices[id].model[1][1] = scaleY;                                // scale y
    _modelMatrices[id].model[2][2] = _oceanUnitSize;                        // scale z
    _modelMatrices[id].model[0][3] = worldPos.x;                            // position x
    _modelMatrices[id].model[1][3] = h;                                     // position y
    _modelMatrices[id].model[2][3] = worldPos.y;                            // position z
    _modelMatrices[id].modelInverse = inverse(_modelMatrices[id].model);    // transform inverse
}