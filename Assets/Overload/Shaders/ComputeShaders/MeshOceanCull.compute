//--------------------------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------------------------
#include "UnityCG.cginc"
#include "Assets/Overload/Shaders/Utils/MeshOcean.hlsl"

//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------
#pragma kernel CSMain

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------
cbuffer CB {
    MESH_OCEAN_DATA
    float4x4 _cameraVP;
};

//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------
RWStructuredBuffer<uint> _indirectArgs;
RWStructuredBuffer<InstanceData> _modelMatrices;

//--------------------------------------------------------------------------------------
// Mesh Ocean Cull Compute Shader
//--------------------------------------------------------------------------------------
[numthreads(32,32,1)]
void CSMain (uint2 id : SV_DispatchThreadID)
{
    if(id.x > _oceanDimension || id.y > _oceanDimension) return;

    const float startU = -_oceanDimension * 0.5; // start position (unit)
    const float startX = (startU + id.x - 0.5) * _oceanUnitSize + _oceanCenter.x + _oceanFluxOffset.x;
    const float startZ = (startU + id.y - 0.5) * _oceanUnitSize + _oceanCenter.z + _oceanFluxOffset.y;

    const float minX = startX;
    const float maxX = startX + _oceanUnitSize;
    const float minY = _oceanCenter.y;
    const float maxY = minY + _oceanMaxHeight;
    const float minZ = startZ;
    const float maxZ = startZ + _oceanUnitSize;

    const uint BOUND_COUNT = 8;
    const float4 bounds[BOUND_COUNT] = {
        float4(minX,minY,minZ,1),
        float4(minX,minY,maxZ,1),
        float4(minX,maxY,minZ,1),
        float4(minX,maxY,maxZ,1),
        float4(maxX,minY,minZ,1),
        float4(maxX,minY,maxZ,1),
        float4(maxX,maxY,minZ,1),
        float4(maxX,maxY,maxZ,1)
    }; 

    // find clip space min and max
    float3 pMin = float3(2,2,2);
    float3 pMax = float3(-2,-2,-2);
    for(uint i = 0; i < BOUND_COUNT; ++i){
        float4 p  = mul(_cameraVP, bounds[i]);
        p.w = max(p.w,0); 
        p /= p.w; // TODO: dividing by zero yield infinity (or nan)
        pMin = min(p.xyz,pMin);
        pMax = max(p.xyz,pMax);
    }

    const bool isCulled = (pMin.z > 1) || (pMin.x > +1) || (pMin.y > +1) || (pMax.z < 0) || (pMax.x < -1) || (pMax.y < -1);
    //if(isCulled) return;

    // instance update
    uint instanceIdx;
    InterlockedAdd(_indirectArgs[1], 1, instanceIdx);
    _modelMatrices[instanceIdx].model[0][0] = float(id.x);
    _modelMatrices[instanceIdx].model[1][1] = float(id.y);
}